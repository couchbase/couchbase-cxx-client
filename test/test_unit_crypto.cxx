/* -*- Mode: C++; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
 *   Copyright 2025. Couchbase, Inc.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */

#include "test_helper.hxx"

#include "core/impl/crypto/aead_aes_256_cbc_hmac_sha512_provider.hxx"
#include "core/logger/logger.hxx"

#include <spdlog/fmt/bundled/core.h>
#include <spdlog/fmt/bundled/printf.h>

#include <couchbase/crypto/aead_aes_256_cbc_hmac_sha512_provider.hxx>
#include <couchbase/crypto/insecure_keyring.hxx>
#include <couchbase/error_codes.hxx>

#include "core/crypto/cbcrypto.h"
#include "core/utils/binary.hxx"
#include "couchbase/codec/tao_json_serializer.hxx"

auto
make_bytes(std::vector<unsigned char> v) -> std::vector<std::byte>
{
  std::vector<std::byte> out{ v.size() };
  std::transform(v.begin(), v.end(), out.begin(), [](int c) {
    return static_cast<std::byte>(c);
  });
  return out;
}

const auto KEY =
  make_bytes({ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c,
               0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
               0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26,
               0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33,
               0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f });

TEST_CASE("unit: cbc_hmac_sha512 test", "[unit]")
{
  const auto data = make_bytes({
    0x54, 0x68, 0x65, 0x20, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x20, 0x70, 0x72, 0x69, 0x6e,
    0x63, 0x69, 0x70, 0x6c, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x41, 0x75, 0x67, 0x75, 0x73, 0x74,
    0x65, 0x20, 0x4b, 0x65, 0x72, 0x63, 0x6b, 0x68, 0x6f, 0x66, 0x66, 0x73, 0x1a, 0xf3, 0x8c,
    0x2d, 0xc2, 0xb9, 0x6f, 0xfd, 0xd8, 0x66, 0x94, 0x09, 0x23, 0x41, 0xbc, 0x04, 0x4a, 0xff,
    0xaa, 0xad, 0xb7, 0x8c, 0x31, 0xc5, 0xda, 0x4b, 0x1b, 0x59, 0x0d, 0x10, 0xff, 0xbd, 0x3d,
    0xd8, 0xd5, 0xd3, 0x02, 0x42, 0x35, 0x26, 0x91, 0x2d, 0xa0, 0x37, 0xec, 0xbc, 0xc7, 0xbd,
    0x82, 0x2c, 0x30, 0x1d, 0xd6, 0x7c, 0x37, 0x3b, 0xcc, 0xb5, 0x84, 0xad, 0x3e, 0x92, 0x79,
    0xc2, 0xe6, 0xd1, 0x2a, 0x13, 0x74, 0xb7, 0x7f, 0x07, 0x75, 0x53, 0xdf, 0x82, 0x94, 0x10,
    0x44, 0x6b, 0x36, 0xeb, 0xd9, 0x70, 0x66, 0x29, 0x6a, 0xe6, 0x42, 0x7e, 0xa7, 0x5c, 0x2e,
    0x08, 0x46, 0xa1, 0x1a, 0x09, 0xcc, 0xf5, 0x37, 0x0d, 0xc8, 0x0b, 0xfe, 0xcb, 0xad, 0x28,
    0xc7, 0x3f, 0x09, 0xb3, 0xa3, 0xb7, 0x5e, 0x66, 0x2a, 0x25, 0x94, 0x41, 0x0a, 0xe4, 0x96,
    0xb2, 0xe2, 0xe6, 0x60, 0x9e, 0x31, 0xe6, 0xe0, 0x2c, 0xc8, 0x37, 0xf0, 0x53, 0xd2, 0x1f,
    0x37, 0xff, 0x4f, 0x51, 0x95, 0x0b, 0xbe, 0x26, 0x38, 0xd0, 0x9d, 0xd7, 0xa4, 0x93, 0x09,
    0x30, 0x80, 0x6d, 0x07, 0x03, 0xb1, 0xf6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x50,
  });

  const auto expected_sig = make_bytes({
    0x4d, 0xd3, 0xb4, 0xc0, 0x88, 0xa7, 0xf4, 0x5c, 0x21, 0x68, 0x39, 0x64, 0x5b, 0x20, 0x12, 0xbf,
    0x2e, 0x62, 0x69, 0xa8, 0xc5, 0x6a, 0x81, 0x6d, 0xbc, 0x1b, 0x26, 0x77, 0x61, 0x95, 0x5b, 0xc5,
    0xfd, 0x30, 0xa5, 0x65, 0xc6, 0x16, 0xff, 0xb2, 0xf3, 0x64, 0xba, 0xec, 0xe6, 0x8f, 0xc4, 0x07,
    0x53, 0xbc, 0xfc, 0x02, 0x5d, 0xde, 0x36, 0x93, 0x75, 0x4a, 0xa1, 0xf5, 0xc3, 0x37, 0x3b, 0x9c,
  });

  const auto key = make_bytes({ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
                                0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
                                0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f });

  auto sig = couchbase::core::utils::to_binary(
    couchbase::core::crypto::CBC_HMAC(couchbase::core::crypto::Algorithm::ALG_SHA512,
                                      { reinterpret_cast<const char*>(key.data()), key.size() },
                                      { reinterpret_cast<const char*>(data.data()), data.size() }));

  REQUIRE(sig == expected_sig);
}

TEST_CASE("unit: aead_aes_256_cbc_hmac_sha512 algorithm", "[unit]")
{
  const auto iv = make_bytes({ 0x1a,
                               0xf3,
                               0x8c,
                               0x2d,
                               0xc2,
                               0xb9,
                               0x6f,
                               0xfd,
                               0xd8,
                               0x66,
                               0x94,
                               0x09,
                               0x23,
                               0x41,
                               0xbc,
                               0x04 });

  const auto plaintext = make_bytes(
    { 0x41, 0x20, 0x63, 0x69, 0x70, 0x68, 0x65, 0x72, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d,
      0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65,
      0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x73, 0x65,
      0x63, 0x72, 0x65, 0x74, 0x2c, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x69, 0x74, 0x20, 0x6d, 0x75,
      0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x66,
      0x61, 0x6c, 0x6c, 0x20, 0x69, 0x6e, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x61,
      0x6e, 0x64, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6e, 0x65, 0x6d,
      0x79, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6f, 0x75, 0x74, 0x20, 0x69, 0x6e, 0x63, 0x6f, 0x6e,
      0x76, 0x65, 0x6e, 0x69, 0x65, 0x6e, 0x63, 0x65 });

  const auto associated_data = make_bytes({
    0x54, 0x68, 0x65, 0x20, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x20, 0x70, 0x72, 0x69,
    0x6e, 0x63, 0x69, 0x70, 0x6c, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x41, 0x75, 0x67, 0x75,
    0x73, 0x74, 0x65, 0x20, 0x4b, 0x65, 0x72, 0x63, 0x6b, 0x68, 0x6f, 0x66, 0x66, 0x73,
  });

  const auto ciphertext = make_bytes(
    { 0x1a, 0xf3, 0x8c, 0x2d, 0xc2, 0xb9, 0x6f, 0xfd, 0xd8, 0x66, 0x94, 0x09, 0x23, 0x41, 0xbc,
      0x04, 0x4a, 0xff, 0xaa, 0xad, 0xb7, 0x8c, 0x31, 0xc5, 0xda, 0x4b, 0x1b, 0x59, 0x0d, 0x10,
      0xff, 0xbd, 0x3d, 0xd8, 0xd5, 0xd3, 0x02, 0x42, 0x35, 0x26, 0x91, 0x2d, 0xa0, 0x37, 0xec,
      0xbc, 0xc7, 0xbd, 0x82, 0x2c, 0x30, 0x1d, 0xd6, 0x7c, 0x37, 0x3b, 0xcc, 0xb5, 0x84, 0xad,
      0x3e, 0x92, 0x79, 0xc2, 0xe6, 0xd1, 0x2a, 0x13, 0x74, 0xb7, 0x7f, 0x07, 0x75, 0x53, 0xdf,
      0x82, 0x94, 0x10, 0x44, 0x6b, 0x36, 0xeb, 0xd9, 0x70, 0x66, 0x29, 0x6a, 0xe6, 0x42, 0x7e,
      0xa7, 0x5c, 0x2e, 0x08, 0x46, 0xa1, 0x1a, 0x09, 0xcc, 0xf5, 0x37, 0x0d, 0xc8, 0x0b, 0xfe,
      0xcb, 0xad, 0x28, 0xc7, 0x3f, 0x09, 0xb3, 0xa3, 0xb7, 0x5e, 0x66, 0x2a, 0x25, 0x94, 0x41,
      0x0a, 0xe4, 0x96, 0xb2, 0xe2, 0xe6, 0x60, 0x9e, 0x31, 0xe6, 0xe0, 0x2c, 0xc8, 0x37, 0xf0,
      0x53, 0xd2, 0x1f, 0x37, 0xff, 0x4f, 0x51, 0x95, 0x0b, 0xbe, 0x26, 0x38, 0xd0, 0x9d, 0xd7,
      0xa4, 0x93, 0x09, 0x30, 0x80, 0x6d, 0x07, 0x03, 0xb1, 0xf6, 0x4d, 0xd3, 0xb4, 0xc0, 0x88,
      0xa7, 0xf4, 0x5c, 0x21, 0x68, 0x39, 0x64, 0x5b, 0x20, 0x12, 0xbf, 0x2e, 0x62, 0x69, 0xa8,
      0xc5, 0x6a, 0x81, 0x6d, 0xbc, 0x1b, 0x26, 0x77, 0x61, 0x95, 0x5b, 0xc5 });

  SECTION("encryption")
  {
    auto [err, encryption_result] =
      couchbase::core::impl::crypto::aead_aes_256_cbc_hmac_sha512_encrypt(
        KEY, iv, plaintext, associated_data);
    REQUIRE_NO_ERROR(err);
    REQUIRE(ciphertext == encryption_result);
  }

  SECTION("decryption")
  {
    auto [err, decryption_result] =
      couchbase::core::impl::crypto::aead_aes_256_cbc_hmac_sha512_decrypt(
        KEY, ciphertext, associated_data);
    REQUIRE_NO_ERROR(err);
    REQUIRE(plaintext == decryption_result);
  }
}

TEST_CASE("unit: insecure keyring", "[unit]")
{
  const auto keyring = std::make_shared<couchbase::crypto::insecure_keyring>(
    std::vector{ couchbase::crypto::key("test-key", make_bytes({ 0x2a, 0x43 })) });

  {
    auto [err, key] = keyring->get("test-key");
    REQUIRE_NO_ERROR(err);
    REQUIRE(key.id() == "test-key");
    REQUIRE(key.bytes() == make_bytes({ 0x2a, 0x43 }));
  }

  {
    auto [err, key] = keyring->get("test-key-2");
    REQUIRE(err.ec() == couchbase::errc::field_level_encryption::crypto_key_not_found);
  }

  {
    keyring->add_key(couchbase::crypto::key("test-key-2", make_bytes({ 0x51, 0x1b })));
    auto [err, key] = keyring->get("test-key-2");
    REQUIRE_NO_ERROR(err);
    REQUIRE(key.id() == "test-key-2");
    REQUIRE(key.bytes() == make_bytes({ 0x51, 0x1b }));
  }
}

TEST_CASE("unit: aead_aes_256_cbc_hmac_sha512_provider", "[unit]")
{
  auto keyring = std::make_shared<couchbase::crypto::insecure_keyring>();
  keyring->add_key(couchbase::crypto::key("test-key", KEY));
  keyring->add_key(couchbase::crypto::key("invalid-key", make_bytes({ 0x00, 0x01, 0x02 })));

  const auto provider =
    couchbase::crypto::aead_aes_256_cbc_hmac_sha512_provider(std::move(keyring));

  const auto plaintext = make_bytes({ 0x22, 0x54, 0x68, 0x65, 0x20, 0x65, 0x6e, 0x65, 0x6d, 0x79,
                                      0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x73, 0x20, 0x74, 0x68, 0x65,
                                      0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x2e, 0x22 });

  SECTION("decrypt")
  {
    couchbase::crypto::encryption_result enc_result{ "AEAD_AES_256_CBC_HMAC_SHA512" };
    enc_result.put("kid", "test-key");
    enc_result.put("ciphertext",
                   "GvOMLcK5b/"
                   "3YZpQJI0G8BLm98oj20ZLdqKDV3MfTuGlWL4R5p5Deykuv2XLW4LcDvnOkmhuUSRbQ8QVEmbjq43XHd"
                   "Om3ColJ6LzoaAtJihk=");

    const auto decrypter = provider.decrypter();
    const auto [dec_err, dec_result] = decrypter->decrypt(enc_result);
    REQUIRE_NO_ERROR(dec_err);
    REQUIRE(plaintext == dec_result);
  }

  SECTION("encrypt & decrypt")
  {
    const auto encrypter = provider.encrypter_for_key("test-key");
    const auto [enc_err, enc_result] = encrypter->encrypt(plaintext);
    REQUIRE_NO_ERROR(enc_err);
    REQUIRE(enc_result.algorithm() == "AEAD_AES_256_CBC_HMAC_SHA512");
    REQUIRE(enc_result.get("kid") == std::make_optional("test-key"));
    REQUIRE(enc_result.get("ciphertext").has_value());

    const auto decrypter = provider.decrypter();
    const auto [dec_err, dec_result] = decrypter->decrypt(enc_result);
    REQUIRE_NO_ERROR(dec_err);
    REQUIRE(plaintext == dec_result);
  }

  SECTION("encrypt missing key")
  {
    const auto encrypter = provider.encrypter_for_key("missing-key");
    const auto [enc_err, enc_result] = encrypter->encrypt(plaintext);
    REQUIRE(enc_err.ec() == couchbase::errc::field_level_encryption::crypto_key_not_found);
  }

  SECTION("encrypt invalid key")
  {
    const auto encrypter = provider.encrypter_for_key("invalid-key");
    const auto [enc_err, enc_result] = encrypter->encrypt(plaintext);
    REQUIRE(enc_err.ec() == couchbase::errc::field_level_encryption::invalid_crypto_key);
  }

  SECTION("decrypt invalid key")
  {
    couchbase::crypto::encryption_result enc_result{ "AEAD_AES_256_CBC_HMAC_SHA512" };
    enc_result.put("kid", "invalid-key");
    enc_result.put("ciphertext",
                   "GvOMLcK5b/"
                   "3YZpQJI0G8BLm98oj20ZLdqKDV3MfTuGlWL4R5p5Deykuv2XLW4LcDvnOkmhuUSRbQ8QVEmbjq43XHd"
                   "Om3ColJ6LzoaAtJihk=");

    const auto decrypter = provider.decrypter();
    const auto [dec_err, dec_result] = decrypter->decrypt(enc_result);
    REQUIRE(dec_err.ec() == couchbase::errc::field_level_encryption::invalid_crypto_key);
  }

  SECTION("decrypt result that is missing key id")
  {
    couchbase::crypto::encryption_result enc_result{ "AEAD_AES_256_CBC_HMAC_SHA512" };
    enc_result.put("ciphertext",
                   "GvOMLcK5b/"
                   "3YZpQJI0G8BLm98oj20ZLdqKDV3MfTuGlWL4R5p5Deykuv2XLW4LcDvnOkmhuUSRbQ8QVEmbjq43XHd"
                   "Om3ColJ6LzoaAtJihk=");

    const auto decrypter = provider.decrypter();
    const auto [dec_err, dec_result] = decrypter->decrypt(enc_result);
    REQUIRE(dec_err.ec() == couchbase::errc::field_level_encryption::decryption_failure);
  }

  SECTION("decrypt result key id is missing from keyring")
  {
    couchbase::crypto::encryption_result enc_result{ "AEAD_AES_256_CBC_HMAC_SHA512" };
    enc_result.put("kid", "missing-key");
    enc_result.put("ciphertext",
                   "GvOMLcK5b/"
                   "3YZpQJI0G8BLm98oj20ZLdqKDV3MfTuGlWL4R5p5Deykuv2XLW4LcDvnOkmhuUSRbQ8QVEmbjq43XHd"
                   "Om3ColJ6LzoaAtJihk=");

    const auto decrypter = provider.decrypter();
    const auto [dec_err, dec_result] = decrypter->decrypt(enc_result);
    REQUIRE(dec_err.ec() == couchbase::errc::field_level_encryption::crypto_key_not_found);
  }

  SECTION("decrypt invalid ciphertext")
  {
    SECTION("ciphertext too short")
    {
      couchbase::crypto::encryption_result enc_result{ "AEAD_AES_256_CBC_HMAC_SHA512" };
      enc_result.put("kid", "test-key");
      enc_result.put("ciphertext", make_bytes({ 0x00, 0x01, 0x02, 0x03 }));

      const auto decrypter = provider.decrypter();
      const auto [dec_err, dec_result] = decrypter->decrypt(enc_result);
      REQUIRE(dec_err.ec() == couchbase::errc::field_level_encryption::invalid_ciphertext);
    }

    SECTION("ciphertext is not valid base64 encoded string")
    {
      couchbase::crypto::encryption_result enc_result{ "AEAD_AES_256_CBC_HMAC_SHA512" };
      enc_result.put("kid", "test-key");
      enc_result.put("ciphertext", "GvOMLcK5b/3YZpQJI0G8BLm98oj20ZLdqKDV3MfTuGlWL4R5p5Deykuv2X");

      const auto decrypter = provider.decrypter();
      const auto [dec_err, dec_result] = decrypter->decrypt(enc_result);
      REQUIRE(dec_err.ec() == couchbase::errc::field_level_encryption::invalid_ciphertext);
      REQUIRE(dec_err.message().find("could not be decoded") != std::string::npos);
      REQUIRE(dec_err.message().find("base64") != std::string::npos);
    }
  }
}

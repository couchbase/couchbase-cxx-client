diff --git a/test/test_transaction_transaction_context.cxx b/test/test_transaction_transaction_context.cxx
index 15610b4..3c52adb 100644
--- a/test/test_transaction_transaction_context.cxx
+++ b/test/test_transaction_transaction_context.cxx
@@ -32,8 +32,7 @@ static const tao::json::value tx_content{
     { "some", "thing" },
 };
 
-void
-txn_completed(std::exception_ptr err, std::shared_ptr<std::promise<void>> barrier)
+void txn_completed(std::exception_ptr err, std::shared_ptr<std::promise<void>> barrier)
 {
     if (err) {
         barrier->set_exception(err);
@@ -158,7 +157,7 @@ TEST_CASE("transactions: can do simple transaction explicit commit", "[transacti
                        });
                    });
     });
-    f.get();
+    wait_for_result(f);
     REQUIRE(TransactionsTestEnvironment::get_doc(id).content_as<tao::json::value>() == new_content);
 }
 
@@ -191,7 +190,7 @@ TEST_CASE("transactions: can do rollback simple transaction", "[transactions]")
                        });
                    });
     });
-    f.get();
+    wait_for_result(f);
     // this should not throw, as errors should be empty.
     REQUIRE_NOTHROW(tx.existing_error());
 }
@@ -219,7 +218,7 @@ TEST_CASE("transactions: can get insert errors", "[transactions]")
                       barrier->set_value();
                   }
               });
-    CHECK_THROWS_AS(f.get(), transaction_operation_failed);
+    CHECK_THROWS_AS(wait_for_result(f), transaction_operation_failed);
     CHECK_THROWS_AS(tx.existing_error(), transaction_operation_failed);
 }
 
@@ -249,7 +248,7 @@ TEST_CASE("transactions: can get remove errors", "[transactions]")
             }
         });
     });
-    CHECK_THROWS_AS(f.get(), transaction_operation_failed);
+    CHECK_THROWS_AS(wait_for_result(f), transaction_operation_failed);
     CHECK_THROWS_AS(tx.existing_error(), transaction_operation_failed);
 }
 
@@ -282,7 +281,7 @@ TEST_CASE("transactions: can get replace errors", "[transactions]")
                        }
                    });
     });
-    CHECK_THROWS_AS(f.get(), transaction_operation_failed);
+    CHECK_THROWS_AS(wait_for_result(f), transaction_operation_failed);
     CHECK_THROWS_AS(tx.existing_error(), transaction_operation_failed);
 }
 
@@ -293,15 +292,18 @@ TEST_CASE("transactions: RYOW get after insert", "[transactions]")
 
     transaction_context tx(txns);
     tx.new_attempt_context();
-    auto logic = [&tx, &id]() {
+    auto barrier = std::make_shared<std::promise<void>>();
+    auto f = barrier->get_future();
+    auto logic = [&tx, &id, barrier]() {
         tx.insert(id,
                   couchbase::core::utils::json::generate_binary(tx_content),
-                  [&tx, &id](std::exception_ptr err, std::optional<transaction_get_result> res) {
+                  [&tx, &id, barrier](std::exception_ptr err, std::optional<transaction_get_result> res) {
                       CHECK_FALSE(err);
                       CHECK(res);
-                      tx.get(id, [](std::exception_ptr err, std::optional<transaction_get_result> res) {
+                      tx.get(id, [barrier](std::exception_ptr err, std::optional<transaction_get_result> res) {
                           CHECK_FALSE(err);
                           CHECK(res->content<tao::json::value>() == tx_content);
+                          barrier->set_value();
                       });
                   });
     };
@@ -329,7 +331,7 @@ TEST_CASE("transactions: can get get errors", "[transactions]")
             barrier->set_value();
         }
     });
-    CHECK_THROWS_AS(f.get(), transaction_operation_failed);
+    CHECK_THROWS_AS(wait_for_result(f), transaction_operation_failed);
     CHECK_THROWS_AS(tx.existing_error(), transaction_operation_failed);
 }
 
@@ -356,7 +358,7 @@ TEST_CASE("transactions: can do query", "[transactions]")
             barrier->set_value();
         }
     });
-    REQUIRE_NOTHROW(f.get());
+    REQUIRE_NOTHROW(wait_for_result(f));
     REQUIRE_NOTHROW(tx.existing_error());
 }
 
@@ -384,7 +386,7 @@ TEST_CASE("transactions: can see some query errors but no transactions failed",
                  }
              });
     try {
-        f.get();
+        wait_for_result(f);
         FAIL("expected future to throw exception");
     } catch (const op_exception&) {
 
diff --git a/test/test_transaction_transaction_public_async_api.cxx b/test/test_transaction_transaction_public_async_api.cxx
index d3f3110..8ca99fb 100644
--- a/test/test_transaction_transaction_public_async_api.cxx
+++ b/test/test_transaction_transaction_public_async_api.cxx
@@ -56,7 +56,7 @@ TEST_CASE("can async get", "[transactions]")
           barrier->set_value();
       },
       async_options());
-    f.get();
+    wait_for_result(f);
 }
 
 TEST_CASE("can get fail as expected", "[transactions]")
@@ -81,7 +81,7 @@ TEST_CASE("can get fail as expected", "[transactions]")
           barrier->set_value();
       },
       async_options());
-    f.get();
+    wait_for_result(f);
 }
 TEST_CASE("can async remove", "[transactions]")
 {
@@ -106,7 +106,7 @@ TEST_CASE("can async remove", "[transactions]")
           barrier->set_value();
       },
       async_options());
-    f.get();
+    wait_for_result(f);
 }
 
 TEST_CASE("async remove with bad cas fails as expected", "[transactions]")
@@ -132,7 +132,7 @@ TEST_CASE("async remove with bad cas fails as expected", "[transactions]")
           barrier->set_value();
       },
       async_options());
-    f.get();
+    wait_for_result(f);
 }
 TEST_CASE("can async insert", "[transactions]")
 {
@@ -155,7 +155,7 @@ TEST_CASE("can async insert", "[transactions]")
           barrier->set_value();
       },
       async_options());
-    f.get();
+    wait_for_result(f);
 }
 
 TEST_CASE("async insert fails when doc already exists", "[transactions]")
@@ -181,7 +181,7 @@ TEST_CASE("async insert fails when doc already exists", "[transactions]")
           barrier->set_value();
       },
       async_options());
-    f.get();
+    wait_for_result(f);
 }
 
 TEST_CASE("can async replace", "[transactions]")
@@ -210,7 +210,7 @@ TEST_CASE("can async replace", "[transactions]")
           barrier->set_value();
       },
       async_options());
-    f.get();
+    wait_for_result(f);
 }
 TEST_CASE("async replace fails as expected with bad cas", "[transactions]")
 {
@@ -237,7 +237,7 @@ TEST_CASE("async replace fails as expected with bad cas", "[transactions]")
           barrier->set_value();
       },
       async_options());
-    f.get();
+    wait_for_result(f);
 }
 
 TEST_CASE("uncaught exception will rollback", "[transactions]")
@@ -267,7 +267,8 @@ TEST_CASE("uncaught exception will rollback", "[transactions]")
           barrier->set_value();
       },
       async_options());
-    f.get();
+
+    wait_for_result(f);
 }
 
 TEST_CASE("can set transaction options", "[transactions]")
@@ -303,7 +304,7 @@ TEST_CASE("can set transaction options", "[transactions]")
       },
       cfg);
 
-    f.get();
+    wait_for_result(f);
 }
 
 TEST_CASE("can do mutating query", "[transactions]")
@@ -324,7 +325,7 @@ TEST_CASE("can do mutating query", "[transactions]")
           CHECK(res.unstaging_complete);
           barrier->set_value();
       });
-    f.get();
+    wait_for_result(f);
 }
 
 TEST_CASE("some query errors rollback", "[transactions]")
@@ -351,5 +352,5 @@ TEST_CASE("some query errors rollback", "[transactions]")
           CHECK_FALSE(res.unstaging_complete);
           barrier->set_value();
       });
-    f.get();
+    wait_for_result(f);
 }
\ No newline at end of file
diff --git a/test/test_transaction_transaction_simple_async.cxx b/test/test_transaction_transaction_simple_async.cxx
index 061c14f..bdab351 100644
--- a/test/test_transaction_transaction_simple_async.cxx
+++ b/test/test_transaction_transaction_simple_async.cxx
@@ -69,7 +69,7 @@ TEST_CASE("transactions: async get", "[transactions]")
           CHECK(cb_called->load());
           txn_completed(std::move(err), std::move(res), barrier);
       });
-    f.get();
+    wait_for_result(f);
 }
 
 TEST_CASE("transactions: can't get from unknown bucket", "[transactions]")
@@ -91,7 +91,7 @@ TEST_CASE("transactions: can't get from unknown bucket", "[transactions]")
           CHECK(cb_called->load());
           txn_completed(std::move(err), std::move(res), barrier);
       });
-    REQUIRE_THROWS_AS(f.get(), transaction_exception);
+    REQUIRE_THROWS_AS(wait_for_result(f), transaction_exception);
     REQUIRE(cb_called->load());
 }
 
@@ -116,7 +116,7 @@ TEST_CASE("transactions: async get fail", "[transactions]")
               CHECK(cb_called->load());
               txn_completed(std::move(err), std::move(res), barrier);
           });
-        f.get();
+        wait_for_result(f);
         FAIL("expected transaction_exception!");
     } catch (const transaction_exception& e) {
         // nothing to do here, but make sure
@@ -155,7 +155,7 @@ TEST_CASE("transactions: async remove fail", "[transactions]")
               CHECK(cb_called->load());
               txn_completed(std::move(err), std::move(res), barrier);
           });
-        f.get();
+        wait_for_result(f);
         FAIL("expected txn to fail until timeout, or error out during rollback");
     } catch (const transaction_exception&) {
         REQUIRE(cb_called->load());
@@ -189,7 +189,7 @@ TEST_CASE("transactions: RYOW on insert", "[transactions]")
           CHECK(cb_called->load());
           txn_completed(err, std::move(res), barrier);
       });
-    f.get();
+    wait_for_result(f);
     REQUIRE(cb_called->load());
 }
 
@@ -217,7 +217,7 @@ TEST_CASE("transactions: async remove", "[transactions]")
           CHECK(cb_called->load());
           txn_completed(std::move(err), res, barrier);
       });
-    f.get();
+    wait_for_result(f);
     REQUIRE(cb_called->load());
     try {
         TransactionsTestEnvironment::get_doc(id);
@@ -259,7 +259,7 @@ TEST_CASE("transactions: async replace", "[transactions]")
           CHECK(cb_called->load());
           txn_completed(std::move(err), res, barrier);
       });
-    f.get();
+    wait_for_result(f);
     REQUIRE(cb_called->load());
     auto content = TransactionsTestEnvironment::get_doc(id).content_as<tao::json::value>();
     REQUIRE(content == new_content);
@@ -296,7 +296,7 @@ TEST_CASE("transactions: async replace fail", "[transactions]")
               CHECK(cb_called->load());
               txn_completed(std::move(err), res, barrier);
           });
-        f.get();
+        wait_for_result(f);
         FAIL("expected exception");
     } catch (const transaction_exception& e) {
         REQUIRE(cb_called->load());
@@ -327,7 +327,7 @@ TEST_CASE("transactions: async insert", "[transactions]")
           CHECK(cb_called->load());
           txn_completed(std::move(err), res, barrier);
       });
-    f.get();
+    wait_for_result(f);
     REQUIRE(cb_called->load());
     REQUIRE(TransactionsTestEnvironment::get_doc(id).content_as<tao::json::value>() == async_content);
 }
@@ -355,7 +355,7 @@ TEST_CASE("transactions: async insert fail", "[transactions]")
               CHECK(err->type() == failure_type::FAIL);
               txn_completed(std::move(err), std::move(result), barrier);
           });
-        f.get();
+        wait_for_result(f);
         FAIL("Expected exception");
     } catch (const transaction_exception& e) {
         REQUIRE(cb_called->load());
@@ -392,7 +392,7 @@ TEST_CASE("transactions: async query", "[transactions]")
           CHECK_FALSE(err);
           txn_completed(std::move(err), std::move(result), barrier);
       });
-    f.get();
+    wait_for_result(f);
     REQUIRE(query_called->load());
     auto content = TransactionsTestEnvironment::get_doc(id).content_as<tao::json::value>();
     REQUIRE(content["some"].as<std::string>() == std::string("thing else"));
@@ -433,7 +433,7 @@ TEST_CASE("transactions: multiple racing queries", "[transactions]")
           CHECK_FALSE(err);
           txn_completed(std::move(err), std::move(result), barrier);
       });
-    f.get();
+    wait_for_result(f);
     REQUIRE(3 == query_called->load());
     auto content = TransactionsTestEnvironment::get_doc(id).content_as<tao::json::value>();
     REQUIRE(content["some"].as<std::string>() == std::string("thing else"));
@@ -464,7 +464,7 @@ TEST_CASE("transactions: rollback async query", "[transactions]")
           CHECK(err);
           txn_completed(std::move(err), std::move(result), barrier);
       });
-    CHECK_THROWS_AS(f.get(), transaction_exception);
+    CHECK_THROWS_AS(wait_for_result(f), transaction_exception);
     REQUIRE(query_called->load());
     REQUIRE(TransactionsTestEnvironment::get_doc(id).content_as<tao::json::value>() == async_content);
 }
@@ -499,7 +499,7 @@ TEST_CASE("transactions: async KV get", "[transactions]")
           CHECK_FALSE(err);
           txn_completed(std::move(err), std::move(result), barrier);
       });
-    f.get();
+    wait_for_result(f);
     REQUIRE(get_called->load());
     REQUIRE(TransactionsTestEnvironment::get_doc(id).content_as<tao::json::value>()["some"].as<std::string>() == "thing else");
 }
@@ -535,7 +535,7 @@ TEST_CASE("transactions: rollback async KV get", "[transactions]")
           CHECK(err);
           txn_completed(std::move(err), std::move(result), barrier);
       });
-    REQUIRE_THROWS_AS(f.get(), transaction_exception);
+    REQUIRE_THROWS_AS(wait_for_result(f), transaction_exception);
     REQUIRE(get_called->load());
     REQUIRE(TransactionsTestEnvironment::get_doc(id).content_as<tao::json::value>()["some"].as<std::string>() == "thing");
 }
@@ -565,7 +565,7 @@ TEST_CASE("transactions: async KV insert", "[transactions]")
           CHECK(insert_called->load());
           txn_completed(std::move(err), std::move(res), barrier);
       });
-    f.get();
+    wait_for_result(f);
     REQUIRE(insert_called->load());
     REQUIRE(TransactionsTestEnvironment::get_doc(id).content_as<tao::json::value>() == async_content);
 }
@@ -597,7 +597,7 @@ TEST_CASE("transactions: rollback async KV insert", "[transactions]")
           CHECK(insert_called->load());
           txn_completed(std::move(err), std::move(res), barrier);
       });
-    REQUIRE_THROWS_AS(f.get(), transaction_exception);
+    REQUIRE_THROWS_AS(wait_for_result(f), transaction_exception);
     REQUIRE(insert_called->load());
     try {
         TransactionsTestEnvironment::get_doc(id);
@@ -648,7 +648,7 @@ TEST_CASE("transactions: async KV replace", "[transactions]")
           CHECK_FALSE(err);
           txn_completed(std::move(err), std::move(result), barrier);
       });
-    f.get();
+    wait_for_result(f);
     REQUIRE(replace_called->load());
     REQUIRE(TransactionsTestEnvironment::get_doc(id).content_as<tao::json::value>() == new_content);
 }
@@ -695,7 +695,7 @@ TEST_CASE("transactions: rollback async KV replace", "[transactions]")
           CHECK(err);
           txn_completed(std::move(err), std::move(result), barrier);
       });
-    REQUIRE_THROWS_AS(f.get(), transaction_exception);
+    REQUIRE_THROWS_AS(wait_for_result(f), transaction_exception);
     REQUIRE(replace_called->load());
     REQUIRE(TransactionsTestEnvironment::get_doc(id).content_as<tao::json::value>() == async_content);
 }
@@ -735,7 +735,7 @@ TEST_CASE("transactions: async KV remove", "[transactions]")
           CHECK_FALSE(err);
           txn_completed(std::move(err), std::move(result), barrier);
       });
-    f.get();
+    wait_for_result(f);
     REQUIRE(remove_called->load());
     try {
         TransactionsTestEnvironment::get_doc(id);
@@ -780,7 +780,7 @@ TEST_CASE("transactions: rollback async KV remove", "[transactions]")
           CHECK(err);
           txn_completed(std::move(err), std::move(result), barrier);
       });
-    REQUIRE_THROWS_AS(f.get(), transaction_exception);
+    REQUIRE_THROWS_AS(wait_for_result(f), transaction_exception);
     REQUIRE(remove_called->load());
     REQUIRE(TransactionsTestEnvironment::get_doc(id).content_as<tao::json::value>() == async_content);
 }
diff --git a/test/utils/transactions_env.h b/test/utils/transactions_env.h
index 06693b0..863c376 100644
--- a/test/utils/transactions_env.h
+++ b/test/utils/transactions_env.h
@@ -58,6 +58,18 @@ struct test_config {
     std::string extra_bucket{ "secBucket" };
 };
 
+// Many txn tests wait for a std::future<void>, and if there are unexpected bugs/issues, we never get
+// the promise set.   This is a way to avoid hanging the entire test suite.
+template<typename R>
+R wait_for_result(std::future<R>& fut, std::chrono::seconds timeout = std::chrono::seconds(20))
+{
+    auto res = fut.wait_for(timeout);
+    if (std::future_status::ready != res) {
+        throw std::runtime_error(fmt::format("future not ready after {} seconds!", timeout.count()));
+    }
+    return fut.get();
+}
+
 template<>
 struct tao::json::traits<test_config> {
     template<template<typename...> class Traits>
